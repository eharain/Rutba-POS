#!/usr/bin/env node
'use strict';

/**
 * scripts/generate-docker-env.js
 *
 * Reads the centralized config (.env → .env.<ENVIRONMENT>) and writes
 * a flat .env.docker file that Docker Compose can consume directly.
 *
 * Usage:
 *   node scripts/generate-docker-env.js            # uses ENVIRONMENT from .env
 *   node scripts/generate-docker-env.js production  # explicit override
 *
 * Output (.env.docker):
 *   - All NEXT_PUBLIC_* globals (for build args + client env)
 *   - POS_STRAPI__* stripped → bare names (DATABASE_CLIENT, etc.)
 *   - RUTBA_WEB__* stripped → bare names (NEXTAUTH_SECRET, etc.)
 *   - PORT_<APP> derived from NEXT_PUBLIC_<APP>_URL
 *   - CORS_ORIGINS auto-computed
 *
 * Then run:  docker compose --env-file .env.docker up --build
 */

const fs = require('fs');
const path = require('path');

const ROOT = path.resolve(__dirname, '..');

// ── .env parser (shared with load-env.js) ──────────────────

function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const content = fs.readFileSync(filePath, 'utf8');
  const vars = {};
  for (const line of content.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) continue;
    const eqIndex = trimmed.indexOf('=');
    if (eqIndex === -1) continue;
    const key = trimmed.slice(0, eqIndex).trim();
    let value = trimmed.slice(eqIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    vars[key] = value;
  }
  return vars;
}

function getAppPrefixes() {
  const pkg = JSON.parse(
    fs.readFileSync(path.join(ROOT, 'package.json'), 'utf8')
  );
  const dirs = [];
  for (const ws of pkg.workspaces || []) {
    if (ws.includes('*')) {
      const base = ws.replace(/\/?\*$/, '');
      const fullBase = path.join(ROOT, base);
      if (fs.existsSync(fullBase)) {
        for (const entry of fs.readdirSync(fullBase, { withFileTypes: true })) {
          if (entry.isDirectory()) dirs.push(entry.name);
        }
      }
    } else {
      dirs.push(ws);
    }
  }
  dirs.push('pos-strapi');
  return dirs.map((d) => d.toUpperCase().replace(/-/g, '_'));
}

// ── main ───────────────────────────────────────────────────

const rootVars = parseEnvFile(path.join(ROOT, '.env'));
const environment = process.argv[2] || rootVars.ENVIRONMENT || 'development';

const envFilePath = path.join(ROOT, `.env.${environment}`);
if (!fs.existsSync(envFilePath)) {
  console.error(`Environment file not found: .env.${environment}`);
  process.exit(1);
}

const allVars = parseEnvFile(envFilePath);
const allPrefixes = getAppPrefixes();
const DELIM = '__';

const globals = {};
const appVars = {}; // { POS_STRAPI: { HOST: '0.0.0.0', ... }, RUTBA_WEB: { ... } }
const allOrigins = new Set();

for (const [key, value] of Object.entries(allVars)) {
  try { allOrigins.add(new URL(value).origin); } catch {}

  const delimIdx = key.indexOf(DELIM);
  if (delimIdx > 0) {
    const prefix = key.slice(0, delimIdx);
    if (allPrefixes.includes(prefix)) {
      if (!appVars[prefix]) appVars[prefix] = {};
      appVars[prefix][key.slice(delimIdx + DELIM.length)] = value;
      continue;
    }
  }
  globals[key] = value;
}

// Derive per-app ports from NEXT_PUBLIC_*_URL
const portMap = {}; // { AUTH: '4003', STOCK: '4001', ... }
const urlPattern = /^NEXT_PUBLIC_(\w+)_URL$/;
for (const [key, value] of Object.entries(globals)) {
  const m = key.match(urlPattern);
  if (m && m[1] !== 'API' && m[1] !== 'IMAGE' && m[1] !== 'IMAGE_HOST') {
    try { portMap[m[1]] = new URL(value).port; } catch {}
  }
}

// Strapi port from app-specific
const strapiVars = appVars['POS_STRAPI'] || {};
const strapiPort = strapiVars.PORT || '4010';

// Compute CORS origins (exclude Strapi's own)
const strapiOrigins = new Set([
  `http://localhost:${strapiPort}`,
  `http://127.0.0.1:${strapiPort}`,
]);
const corsOrigins = [...allOrigins].filter((o) => !strapiOrigins.has(o));

// ── write .env.docker ──────────────────────────────────────

const lines = [
  '# ============================================================',
  '# .env.docker — Auto-generated by scripts/generate-docker-env.js',
  `# Source: .env.${environment}`,
  '# Re-generate:  node scripts/generate-docker-env.js',
  '# Usage:        docker compose --env-file .env.docker up --build',
  '# ============================================================',
  '',
  '# --- Global variables (NEXT_PUBLIC_*) ---',
];

for (const [k, v] of Object.entries(globals)) {
  lines.push(`${k}=${v}`);
}

lines.push('', '# --- Per-app ports (derived from NEXT_PUBLIC_*_URL) ---');
for (const [name, port] of Object.entries(portMap)) {
  lines.push(`PORT_${name}=${port}`);
}
lines.push(`PORT_STRAPI=${strapiPort}`);

lines.push('', '# --- Strapi runtime (POS_STRAPI__ stripped) ---');
for (const [k, v] of Object.entries(strapiVars)) {
  lines.push(`STRAPI_${k}=${v}`);
}

lines.push('', '# --- CORS origins (auto-computed) ---');
lines.push(`CORS_ORIGINS=${corsOrigins.join(',')}`);

// Web runtime vars
const webVars = appVars['RUTBA_WEB'] || {};
if (Object.keys(webVars).length) {
  lines.push('', '# --- Rutba Web runtime (RUTBA_WEB__ stripped) ---');
  for (const [k, v] of Object.entries(webVars)) {
    lines.push(`WEB_${k}=${v}`);
  }
}

lines.push('');

const outPath = path.join(ROOT, '.env.docker');
fs.writeFileSync(outPath, lines.join('\n'), 'utf8');
console.log(`Generated ${outPath} from .env.${environment}`);
